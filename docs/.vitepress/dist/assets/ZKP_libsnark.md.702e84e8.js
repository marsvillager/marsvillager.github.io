import{_ as r,o as e,c as t,O as a}from"./chunks/framework.02642853.js";const h=JSON.parse('{"title":"Structure","description":"","frontmatter":{},"headers":[],"relativePath":"ZKP_libsnark.md"}'),i={name:"ZKP_libsnark.md"},o=a('<h1 id="structure" tabindex="-1">Structure <a class="header-anchor" href="#structure" aria-label="Permalink to &quot;Structure&quot;">​</a></h1><p>目录结构</p><ul><li><strong>common</strong>：通用数据结构，i.e. Merkle tree, sparse vector, etc.</li><li><strong>relations</strong>：约束关系，i.e. R1CS</li><li><strong>reductions</strong>：不同语言之间的转换</li><li><strong>knowledge_commitment</strong>：引入配对的概念，基于 multiexp</li><li><strong>zk_proof_systems</strong>：零知识证明中的不同证明系统，i.e. Groth16, GM17, etc.</li><li><strong>gadgetlib1/gadgetlib2</strong>：用于构建新电路的小工具</li></ul><h1 id="relation" tabindex="-1">Relation <a class="header-anchor" href="#relation" aria-label="Permalink to &quot;Relation&quot;">​</a></h1><h2 id="约束可满足问题" tabindex="-1">约束可满足问题 <a class="header-anchor" href="#约束可满足问题" aria-label="Permalink to &quot;约束可满足问题&quot;">​</a></h2><ul><li><strong>R1CS</strong> — Rank-1 Constraint System <ul><li>$(A \\mathcal{z}) \\odot (B \\mathcal{z}) - (C \\mathcal{z}) = 0$</li></ul></li><li><strong>USCS</strong> — Unitary-Square Constraint System</li></ul><h2 id="电路可满足" tabindex="-1">电路可满足 <a class="header-anchor" href="#电路可满足" aria-label="Permalink to &quot;电路可满足&quot;">​</a></h2><ul><li><strong>BACS</strong> — Bilinear Arithmetic Circuit Satisfiability</li><li><strong>TBCS</strong> — Two-input Boolean Circuit Satisfiability</li></ul><h2 id="ram-random-access-machine" tabindex="-1">RAM（Random Access Machine） <a class="header-anchor" href="#ram-random-access-machine" aria-label="Permalink to &quot;RAM（Random Access Machine）&quot;">​</a></h2><ul><li><strong>tinyRAM</strong></li><li><strong>fooRAM</strong></li></ul><h2 id="算数程序" tabindex="-1">算数程序 <a class="header-anchor" href="#算数程序" aria-label="Permalink to &quot;算数程序&quot;">​</a></h2><ul><li><strong>QAP</strong> — Quadratic Arithmetic Program（GGPR13） <ul><li>多项式的内积运算</li><li>$\\frac{(A(x) \\mathcal{z}) \\odot (B(x) \\mathcal{z}) - (C(x) \\mathcal{z})}{Z(x)} = H$</li></ul></li><li><strong>SQP</strong> — Square Arithmetic Program（GM17）</li><li><strong>SSP</strong> — Square Span Program (DFGK14)</li></ul><h1 id="zk-proof-system" tabindex="-1">ZK Proof System <a class="header-anchor" href="#zk-proof-system" aria-label="Permalink to &quot;ZK Proof System&quot;">​</a></h1><p>libsnark 提供了四种证明系统：</p><ul><li><p><strong>pcd</strong> (Proof-Carrying Data)</p><ul><li>由 Chiesa 等人在 2010 年论文《<a href="https://people.eecs.berkeley.edu/~alexch/docs/CT10.pdf" target="_blank" rel="noreferrer">Proof-Carrying Data and Hearsay Arguments from Signature Cards</a>》中提出，可用于不信任的各方进行分布式无限计算，保证每个计算的中间状态都可以succinctly verified</li><li>r1cs_pcd</li></ul></li><li><p><strong>ppzkadsnark</strong> (PreProcessing Zero-Knowledge Succinct Non-interactive Argument of Knowledge Over Authenticated Data)</p><ul><li>r1cs_ppzkadsnark</li></ul></li><li><p><strong>ppzksnark</strong> (PreProcessing Zero-Knowledge Succinct Non-interactive Argument of Knowledge)</p><ul><li><p><code>preprocessing</code> 其实就是指我们常说的 trusted setup，即在证明生成和验证之前，需要通过一个生成算法来创建相关的公共参数（<strong>pk: proving key</strong> 和 <strong>vk: verification key</strong>）。我们也把这个提前生成的参数称为 「公共参考串」（Common Reference String），或简称为 CRS。</p></li><li><p>bacs_ppzksnark</p></li><li><p>r1cs_ppzksnark, <strong>PGHR13/BCTV14a</strong></p></li><li><p>r1cs_gg_ppzksnark, gg = General Group, <strong>Groth16</strong></p><ul><li>primary input: statement</li><li>auxiliary input: witness</li></ul><p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LY1JDHWJFVHddIwQMjzYGw.png" alt="groth16"></p></li><li><p>r1cs_se_ppzksnark, se = Simulation Extractable, <strong>GM17</strong></p></li><li><p>ram_ppzksnark</p></li><li><p>tbcs_ppzksnark</p></li><li><p>uscs_ppzksnark</p></li></ul></li><li><p><strong>zksnark</strong> (Zero-Knowledge Succinct Non-interactive Argument of Knowledge)</p><ul><li>ram_zksnark</li></ul></li></ul><h1 id="reference" tabindex="-1">Reference <a class="header-anchor" href="#reference" aria-label="Permalink to &quot;Reference&quot;">​</a></h1><ul><li><a href="https://trapdoortech.medium.com/zero-knowledge-proof-deep-into-libsnark-a3f02949f064" target="_blank" rel="noreferrer">https://trapdoortech.medium.com/zero-knowledge-proof-deep-into-libsnark-a3f02949f064</a></li></ul>',17),l=[o];function n(s,c,p,u,g,d){return e(),t("div",null,l)}const k=r(i,[["render",n]]);export{h as __pageData,k as default};
