import{_ as e,o as t,c as n,O as a,z as s,a as l}from"./chunks/framework.aacc0fa0.js";const x=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"ZKP_libsnark.md"}'),r={name:"ZKP_libsnark.md"},i=a('<div class="info custom-block"><p class="custom-block-title">INFO</p><p>Zero-Knowledge Proof</p></div><h2 id="structure" tabindex="-1">Structure <a class="header-anchor" href="#structure" aria-label="Permalink to &quot;Structure&quot;">​</a></h2><p>目录结构</p><ul><li><strong>common</strong>：通用数据结构，i.e. Merkle tree, sparse vector, etc.</li><li><strong>relations</strong>：约束关系，i.e. R1CS</li><li><strong>reductions</strong>：不同语言之间的转换</li><li><strong>knowledge_commitment</strong>：引入配对的概念，基于 multiexp</li><li><strong>zk_proof_systems</strong>：零知识证明中的不同证明系统，i.e. Groth16, GM17, etc.</li><li><strong>gadgetlib1/gadgetlib2</strong>：用于构建新电路的小工具</li></ul><h2 id="relation" tabindex="-1">Relation <a class="header-anchor" href="#relation" aria-label="Permalink to &quot;Relation&quot;">​</a></h2><h3 id="约束可满足问题" tabindex="-1">约束可满足问题 <a class="header-anchor" href="#约束可满足问题" aria-label="Permalink to &quot;约束可满足问题&quot;">​</a></h3>',6),o=s("ul",null,[s("li",null,[s("strong",null,"R1CS"),l(" — Rank-1 Constraint System "),s("ul",null,[s("li",null,[s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",null,[s("semantics",null,[s("mrow",null,[s("mo",null,"("),s("mi",null,"A"),s("mrow",null,[s("mi",null,"z")]),s("mo",null,")"),s("mo",null,"⊙"),s("mo",null,"("),s("mi",null,"B"),s("mrow",null,[s("mi",null,"z")]),s("mo",null,")"),s("mo",null,"−"),s("mo",null,"("),s("mi",null,"C"),s("mrow",null,[s("mi",null,"z")]),s("mo",null,")"),s("mo",null,"="),s("mn",null,"0")]),s("annotation",{encoding:"application/x-tex"},"(A \\mathcal{z}) \\odot (B \\mathcal{z}) - (C \\mathcal{z}) = 0")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"strut",style:{height:"0.75em"}}),s("span",{class:"strut bottom",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"base textstyle uncramped"},[s("span",{class:"mopen"},"("),s("span",{class:"mord mathit"},"A"),s("span",{class:"mord textstyle uncramped"},[s("span",{class:"mord mathit",style:{"margin-right":"0.04398em"}},"z")]),s("span",{class:"mclose"},")"),s("span",{class:"mbin"},"⊙"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathit",style:{"margin-right":"0.05017em"}},"B"),s("span",{class:"mord textstyle uncramped"},[s("span",{class:"mord mathit",style:{"margin-right":"0.04398em"}},"z")]),s("span",{class:"mclose"},")"),s("span",{class:"mbin"},"−"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathit",style:{"margin-right":"0.07153em"}},"C"),s("span",{class:"mord textstyle uncramped"},[s("span",{class:"mord mathit",style:{"margin-right":"0.04398em"}},"z")]),s("span",{class:"mclose"},")"),s("span",{class:"mrel"},"="),s("span",{class:"mord mathrm"},"0")])])])])])]),s("li",null,[s("strong",null,"USCS"),l(" — Unitary-Square Constraint System")])],-1),m=a('<h3 id="电路可满足" tabindex="-1">电路可满足 <a class="header-anchor" href="#电路可满足" aria-label="Permalink to &quot;电路可满足&quot;">​</a></h3><ul><li><strong>BACS</strong> — Bilinear Arithmetic Circuit Satisfiability</li><li><strong>TBCS</strong> — Two-input Boolean Circuit Satisfiability</li></ul><h3 id="ram-random-access-machine" tabindex="-1">RAM（Random Access Machine） <a class="header-anchor" href="#ram-random-access-machine" aria-label="Permalink to &quot;RAM（Random Access Machine）&quot;">​</a></h3><ul><li><strong>tinyRAM</strong></li><li><strong>fooRAM</strong></li></ul><h3 id="算数程序" tabindex="-1">算数程序 <a class="header-anchor" href="#算数程序" aria-label="Permalink to &quot;算数程序&quot;">​</a></h3>',5),c=s("ul",null,[s("li",null,[s("strong",null,"QAP"),l(" — Quadratic Arithmetic Program（GGPR13） "),s("ul",null,[s("li",null,"多项式的内积运算"),s("li",null,[s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",null,[s("semantics",null,[s("mrow",null,[s("mfrac",null,[s("mrow",null,[s("mo",null,"("),s("mi",null,"A"),s("mo",null,"("),s("mi",null,"x"),s("mo",null,")"),s("mrow",null,[s("mi",null,"z")]),s("mo",null,")"),s("mo",null,"⊙"),s("mo",null,"("),s("mi",null,"B"),s("mo",null,"("),s("mi",null,"x"),s("mo",null,")"),s("mrow",null,[s("mi",null,"z")]),s("mo",null,")"),s("mo",null,"−"),s("mo",null,"("),s("mi",null,"C"),s("mo",null,"("),s("mi",null,"x"),s("mo",null,")"),s("mrow",null,[s("mi",null,"z")]),s("mo",null,")")]),s("mrow",null,[s("mi",null,"Z"),s("mo",null,"("),s("mi",null,"x"),s("mo",null,")")])]),s("mo",null,"="),s("mi",null,"H")]),s("annotation",{encoding:"application/x-tex"},"\\frac{(A(x) \\mathcal{z}) \\odot (B(x) \\mathcal{z}) - (C(x) \\mathcal{z})}{Z(x)} = H")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"strut",style:{height:"1.01em"}}),s("span",{class:"strut bottom",style:{height:"1.53em","vertical-align":"-0.52em"}}),s("span",{class:"base textstyle uncramped"},[s("span",{class:"mord reset-textstyle textstyle uncramped"},[s("span",{class:"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"}),s("span",{class:"mfrac"},[s("span",{class:"vlist"},[s("span",{style:{top:"0.34500000000000003em"}},[s("span",{class:"fontsize-ensurer reset-size5 size5"},[s("span",{style:{"font-size":"0em"}},"​")]),s("span",{class:"reset-textstyle scriptstyle cramped"},[s("span",{class:"mord scriptstyle cramped"},[s("span",{class:"mord mathit",style:{"margin-right":"0.07153em"}},"Z"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathit"},"x"),s("span",{class:"mclose"},")")])])]),s("span",{style:{top:"-0.22999999999999998em"}},[s("span",{class:"fontsize-ensurer reset-size5 size5"},[s("span",{style:{"font-size":"0em"}},"​")]),s("span",{class:"reset-textstyle textstyle uncramped frac-line"})]),s("span",{style:{top:"-0.485em"}},[s("span",{class:"fontsize-ensurer reset-size5 size5"},[s("span",{style:{"font-size":"0em"}},"​")]),s("span",{class:"reset-textstyle scriptstyle uncramped"},[s("span",{class:"mord scriptstyle uncramped"},[s("span",{class:"mopen"},"("),s("span",{class:"mord mathit"},"A"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathit"},"x"),s("span",{class:"mclose"},")"),s("span",{class:"mord scriptstyle uncramped"},[s("span",{class:"mord mathit",style:{"margin-right":"0.04398em"}},"z")]),s("span",{class:"mclose"},")"),s("span",{class:"mbin"},"⊙"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathit",style:{"margin-right":"0.05017em"}},"B"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathit"},"x"),s("span",{class:"mclose"},")"),s("span",{class:"mord scriptstyle uncramped"},[s("span",{class:"mord mathit",style:{"margin-right":"0.04398em"}},"z")]),s("span",{class:"mclose"},")"),s("span",{class:"mbin"},"−"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathit",style:{"margin-right":"0.07153em"}},"C"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathit"},"x"),s("span",{class:"mclose"},")"),s("span",{class:"mord scriptstyle uncramped"},[s("span",{class:"mord mathit",style:{"margin-right":"0.04398em"}},"z")]),s("span",{class:"mclose"},")")])])]),s("span",{class:"baseline-fix"},[s("span",{class:"fontsize-ensurer reset-size5 size5"},[s("span",{style:{"font-size":"0em"}},"​")]),l("​")])])]),s("span",{class:"sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"})]),s("span",{class:"mrel"},"="),s("span",{class:"mord mathit",style:{"margin-right":"0.08125em"}},"H")])])])])])]),s("li",null,[s("strong",null,"SQP"),l(" — Square Arithmetic Program（GM17）")]),s("li",null,[s("strong",null,"SSP"),l(" — Square Span Program (DFGK14)")])],-1),p=a('<h2 id="zk-proof-system" tabindex="-1">ZK Proof System <a class="header-anchor" href="#zk-proof-system" aria-label="Permalink to &quot;ZK Proof System&quot;">​</a></h2><p>libsnark 提供了四种证明系统：</p><ul><li><p><strong>pcd</strong> (Proof-Carrying Data)</p><ul><li>由 Chiesa 等人在 2010 年论文《<a href="https://people.eecs.berkeley.edu/~alexch/docs/CT10.pdf" target="_blank" rel="noreferrer">Proof-Carrying Data and Hearsay Arguments from Signature Cards</a>》中提出，可用于不信任的各方进行分布式无限计算，保证每个计算的中间状态都可以succinctly verified</li><li>r1cs_pcd</li></ul></li><li><p><strong>ppzkadsnark</strong> (PreProcessing Zero-Knowledge Succinct Non-interactive Argument of Knowledge Over Authenticated Data)</p><ul><li>r1cs_ppzkadsnark</li></ul></li><li><p><strong>ppzksnark</strong> (PreProcessing Zero-Knowledge Succinct Non-interactive Argument of Knowledge)</p><ul><li><p><code>preprocessing</code> 其实就是指我们常说的 trusted setup，即在证明生成和验证之前，需要通过一个生成算法来创建相关的公共参数（<strong>pk: proving key</strong> 和 <strong>vk: verification key</strong>）。我们也把这个提前生成的参数称为 「公共参考串」（Common Reference String），或简称为 CRS。</p></li><li><p>bacs_ppzksnark</p></li><li><p>r1cs_ppzksnark, <strong>PGHR13/BCTV14a</strong></p></li><li><p>r1cs_gg_ppzksnark, gg = General Group, <strong>Groth16</strong></p><ul><li>primary input: statement</li><li>auxiliary input: witness</li></ul><p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LY1JDHWJFVHddIwQMjzYGw.png" alt="groth16"></p></li><li><p>r1cs_se_ppzksnark, se = Simulation Extractable, <strong>GM17</strong></p></li><li><p>ram_ppzksnark</p></li><li><p>tbcs_ppzksnark</p></li><li><p>uscs_ppzksnark</p></li></ul></li><li><p><strong>zksnark</strong> (Zero-Knowledge Succinct Non-interactive Argument of Knowledge)</p><ul><li>ram_zksnark</li></ul></li></ul><h2 id="reference" tabindex="-1">Reference <a class="header-anchor" href="#reference" aria-label="Permalink to &quot;Reference&quot;">​</a></h2><ul><li><a href="https://trapdoortech.medium.com/zero-knowledge-proof-deep-into-libsnark-a3f02949f064" target="_blank" rel="noreferrer">https://trapdoortech.medium.com/zero-knowledge-proof-deep-into-libsnark-a3f02949f064</a></li></ul>',5),u=[i,o,m,c,p];function d(h,g,_,y,f,k){return t(),n("div",null,u)}const b=e(r,[["render",d]]);export{x as __pageData,b as default};
